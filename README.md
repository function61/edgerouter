![Build status](https://github.com/function61/edgerouter/workflows/Build/badge.svg)
[![Download](https://img.shields.io/github/downloads/function61/edgerouter/total.svg?style=for-the-badge)](https://github.com/function61/edgerouter/releases)
[![MicroBadger Size](https://img.shields.io/microbadger/image-size/fn61/edgerouter.svg?style=for-the-badge&label=Docker+image)](https://hub.docker.com/r/fn61/edgerouter/)
[![GoDoc](https://img.shields.io/badge/godoc-reference-5272B4.svg?style=for-the-badge)](https://pkg.go.dev/github.com/function61/edgerouter)

Easy clustering-native, multi-tenancy aware loadbalancer for Docker services, AWS Lambda
functions and S3 static websites.

![Architecture drawing](docs/architecture.png)

Contents:

- [Features](#features)
- [Documentation](#documentation)
- [Application configuration](#application-configuration)


Features
--------

- Prometheus metrics
- Clustering-native
  * All state that is required to exist on all loadbalancer nodes come from an event bus
    (which is durable and has exact-once msg semantics), so each nodes easily reach the
    same config.
- Dynamically discovers Docker services (Swarm and standalone containers supported).
  * Kubernetes is not currently supported.
- [CertBus](https://github.com/function61/certbus) integration for always up-to-date TLS
  certificates
- Emulates AWS API Gateway for calling Lambda functions
- S3 static website support
  * Why use LB in front of S3? Deploys to plain S3 are not atomic. That means users can
    see broken, in-progress, updates or worse yet - canceled deploy can end up in unknown
    state. We support atomic deploys on top of S3 with great caching characteristics.
  * This also makes it possible to overlay dynamic stuff "on top of" a static website.
    Think `/` mounted to S3 but `/api` mounted as a Lambda function.
- Manually defined applications (this hostname should be proxied to this IP..)
- Authorization support
  * For simple websites like (static websites) or backoffice interactive HTTP services that
    you don't have control of (likes of Prometheus, Grafana), it's derirable for loadbalancer
    to enforce backend-wide authentication.
  * For any advanced use, it's of course preferred to do in-app authentication so you can
    have advanced control of things like different auth for interactive vs. API users etc.
- Opinionated
  * Not meant to support everyone's use cases. Do the few things we do, really well.

TODO features: look at [issues](https://github.com/function61/edgerouter/issues).


Documentation
-------------

- [Installation](docs/installation/README.md)
  * Also covers setting up, configuration, AWS IAM permissions
- [Managing S3 static websites](docs/s3-static-websites/README.md)
- [Enabling the admin UI](docs/enabling-the-admin-ui/README.md)
  * Also explains authentication middleware

TODO: more documentation


Application configuration
-------------------------

Edgerouter consumes these [EventHorizon](https://github.com/function61/eventhorizon)
streams for realtime updates:

- `/t-1/certbus`
  * TLS certificate updates happen here
- `/t-1/loadbalancer`
  * Static application definitions are updated here. "Static" doesn't mean the applications
    don't evolve - it means that they-re semi permanent. The static definition is updated
    each time a S3 static website is deployed. Lambda definitions rarely change.

Services/containers discovered from Docker are mostly
[Traefik-notation compliant](https://docs.traefik.io/v1.7/configuration/backends/docker/),
so labels like `traefik.frontend.rule`, `traefik.port` etc are parsed into an app config.
See [test cases](pkg/erdiscovery/swarmdiscovery/traefikannotations_test.go) for supported directives.

"Static" application configs can be published via EventHorizon and all Edgerouter nodes in
the cluster will pick up the same changes.

All application configs, whether they're dynamically created from Docker or retrieved via
EventHorizon follow this structure:

```javascript
{
  "id": "example.com",
  "frontends": [
    {
      "kind": "hostname",
      "hostname": "example.com",
      "path_prefix": "/"
    }
  ],
  "backend": {
    "kind": "s3_static_website",
    "s3_static_website_opts": {
      "bucket_name": "mycompany-staticwebsites",
      "region_id": "eu-central-1",
      "deployed_version": "v1"
    }
  }
}
```

An application always has an ID, at least one frontend (= hostname or hostname pattern),
and a single backend (one backend can have multiple replicas for loadbalancing/high
availability though).

Here's an example of a Docker-discovered service with 2 replicas (remember, this config is
autogenerated):

```javascript
{
  "id": "app.example.com",
  "frontends": [
    {
      "kind": "hostname",
      "hostname": "app.example.com",
      "path_prefix": "/"
    }
  ],
  "backend": {
    "kind": "peer_set",
    "peer_set_opts": {
      "addrs": [
        "http://192.168.1.2"
        "http://192.168.1.3"
      ]
    }
  }
}
```
